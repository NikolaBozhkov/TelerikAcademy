Design pattern: Simple Factory
	* Used to decide which manufacturer to create, implementation in file ManufacturerSelector.cs

Design pattern: Strategy
	* Used in a lot of places, the manufacturing is one

Design pattern: Template Method
	* Used partially in the manufacturing

Design pattern: Abstract factory
	* Used for device manufacturers, can be found in the folder DeviceManufacturers

Design pattern: Composite
	* Couldn't use this one, because I used the motherboard for the reason, the composite was gonna make all the components act like one

Design pattern: Mediator
	* Usage of motherboard as mediator, so the components of the computer can talk to each other, without being coupled

Found bottlenecks:
	* A useless while cycle, when generating random numbers in the cpu
	* When cpu was calculating square of a number it was performing for cycle with steps = to the number, which is useless

Found bugs:
	* When calculating the square of a number it was actually summing all numbers to the desired
	* I think I saw the rest, but then I forgot them, anyways, I think all bugs are fixed : )
	* 

Single responsibility principle
	* Everything is separated into strict classes and does only what it's suppossed to

Open/closed principle
	* In order to extend the devices you do not need to change anything basic you just add new class, Hard drive is changed to allow such behaviour, which was not present before. Now it's easy to extend it.

Liskov substitution principle
	* All devices inherit the base class and the base class can be replaced with all if the inheriters(idk about that word), also applied for the manufacturers

Interface segregation principle
	* Applied when the computer class was divided into small ones, now there are no unused methods, or dependencies to such methods

Dependency inversion principle
	* Everything is left for the client to pick, there is no forced dependency
